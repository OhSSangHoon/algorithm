import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

public class HW1 {
	public static void main(String[] args) {
	    int targetUser;
	    int userNumber;
	    int category;

	    Scanner sc = new Scanner(System.in);
	    String fileName = sc.nextLine();
	    targetUser = sc.nextInt();
	    userNumber = sc.nextInt();
	    category = sc.nextInt();
	    sc.close();

	    FileProcessor fileProcessor = new FileProcessor();

	    try {
	        List<List<Integer>> usersContentScores = fileProcessor.readFileAndProcessContent(fileName, userNumber, category);

	        System.out.println("1. 사용자 " + targetUser + "의 콘텐츠와 정규화 점수: ");
	        System.out.println(getNormalizedContentScores(targetUser, usersContentScores));

	        int mostSimilarUser = findMostSimilarUser(targetUser, userNumber, usersContentScores);
	        System.out.println("2. 유사한 사용자 id와 유사도 리스트");
	        System.out.println("사용자 id: " + mostSimilarUser + ", 유사도: " + String.format("%.6f", findCosineSimilarity(usersContentScores.get(targetUser), usersContentScores.get(mostSimilarUser))));

	        System.out.println("3. 사용자 " + targetUser + "에게 추천할 콘텐츠와 추천 점수");
	        System.out.println(getContentRecommendations(targetUser, mostSimilarUser, category, usersContentScores));

	    } catch (IOException e) {
	        e.printStackTrace();
	    }
	}


    private static double findCosineSimilarity(List<Integer> user1, List<Integer> user2) {
        int dotProduct = 0;
        int sum1Squared = 0;
        int sum2Squared = 0;

        for (int i = 0; i < user1.size(); i++) {
            int score1 = user1.get(i);
            int score2 = user2.get(i);
            dotProduct += score1 * score2;
            sum1Squared += score1 * score1;
            sum2Squared += score2 * score2;
        }

        return dotProduct / (Math.sqrt(sum1Squared) * Math.sqrt(sum2Squared));
    }

    private static int findMostSimilarUser(int targetUser, List<List<Integer>> usersContentScores) {
        int mostSimilarUser = -1;
        double maxSimilarity = Double.NEGATIVE_INFINITY;

        for (int i = 0; i < usersContentScores.size(); i++) {
            if (i == targetUser) {
                continue;
            }

            double similarity = findCosineSimilarity(usersContentScores.get(targetUser), usersContentScores.get(i));

            if (similarity > maxSimilarity) {
                maxSimilarity = similarity;
                mostSimilarUser = i;
            }
        }

        return mostSimilarUser;
    }

    private static String getNormalizedScores(List<Integer> userScores) {
        return userScores.stream()
                .map(score -> String.format("(A%d, %.3f)", userScores.indexOf(score), (score - 1) / 3.0))
                .collect(Collectors.joining(", "));
    }

    private static String getRecommendedContents(int targetUser, List<List<Integer>> usersContentScores, int category) {
        int mostSimilarUser = findMostSimilarUser(targetUser, usersContentScores);
        List<Integer> targetUserScores = usersContentScores.get(targetUser);
        List<Integer> mostSimilarUserScores = usersContentScores.get(mostSimilarUser);
        List<ContentRecommendation> recommendations = new ArrayList<>();

        for (int i = 0; i < category; i++) {
            if (targetUserScores.get(i) == 0 && mostSimilarUserScores.get(i) > 0) {
                double recommendationScore = mostSimilarUserScores.get(i) * findCosineSimilarity(targetUserScores, mostSimilarUserScores);
                recommendations.add(new ContentRecommendation(i, recommendationScore));
            }
        }

        recommendations.sort(Comparator.comparingDouble(ContentRecommendation::getRecommendationScore).reversed());

        return recommendations.stream()
                .map(recommendation -> String.format("[(C%d, %.3f)]", recommendation.getContentIndex(), recommendation.getRecommendationScore()))
                .collect(Collectors.joining(", "));
    }

    private static class ContentRecommendation {
        private final int contentIndex;
        private final double recommendationScore;

        public ContentRecommendation(int contentIndex, double recommendationScore) {
            this.contentIndex = contentIndex;
            this.recommendationScore = recommendationScore;
        }

        public int getContentIndex() {
            return contentIndex;
        }

        public double getRecommendationScore() {
            return recommendationScore;
        }
    }

    private static class FileProcessor {
        private List<List<Integer>> readFileAndProcessContent(String fileName, int userNumber, int category) throws IOException {
            List<List<Integer>> usersContentScores = new ArrayList<>();

            try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {
                String line;

                while ((line = reader.readLine()) != null) {
                    String[] scores = line.split(" ");
                    List<Integer> contentScores = new ArrayList<>();

                    for (String score : scores) {
                        contentScores.add(Integer.parseInt(score));
                    }

                    usersContentScores.add(contentScores);
                }
            }

            return usersContentScores;
        }
    }
}
