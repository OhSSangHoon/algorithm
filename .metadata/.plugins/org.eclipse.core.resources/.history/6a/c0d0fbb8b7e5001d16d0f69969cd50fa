import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

public class HW1 {
    public static void main(String[] args) {
        int targetUser;
        int userNumber;
        int category;

        Scanner sc = new Scanner(System.in);
        String fileName = sc.nextLine();
        targetUser = sc.nextInt();
        userNumber = sc.nextInt();
        category = sc.nextInt();
        sc.close();

        FileProcessor fileProcessor = new FileProcessor();

        try {
            List<List<Integer>> usersContentScores = fileProcessor.readFileAndProcessContent(fileName, userNumber, category);
            int mostSimilarUser = findMostSimilarUser(targetUser, usersContentScores);
            System.out.println("타겟 사용자와 가장 유사한 사용자: " + mostSimilarUser);
            System.out.println("가장 유사한 사용자의 점수: " + usersContentScores.get(mostSimilarUser));

            System.out.println("1. 사용자 " + targetUser + "의 콘텐츠와 정규화 점수:");
            System.out.println(getNormalizedScores(usersContentScores.get(targetUser)));

            System.out.println("2. 유사한 사용자 id와 유사도 리스트");
            System.out.println("사용자 id: " + mostSimilarUser + ", 유사도: " + findCosineSimilarity(usersContentScores.get(targetUser), usersContentScores.get(mostSimilarUser)));

            System.out.println("3. 사용자 " + targetUser + "에게 추천할 콘텐츠와 추천 점수");
            System.out.println(getRecommendedContents(targetUser, usersContentScores, category));

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static double findCosineSimilarity(List<Integer> user1, List<Integer> user2) {
        int dotProduct = 0;
        int sum1Squared = 0;
        int sum2Squared = 0;

        for (int i = 0; i < user1.size(); i++) {
            int score1 = user1.get(i);
            int score2 = user2.get(i);
            dotProduct += score1 * score2;
            sum1Squared += score1 * score1;
            sum2Squared += score2 * score2;
        }

        return dotProduct / (Math.sqrt(sum1Squared) * Math.sqrt(sum2Squared));
    }

    private static int findMostSimilarUser(int targetUser, List<List<Integer>> usersContentScores) {
        int mostSimilarUser = -1;
        double maxSimilarity = Double.NEGATIVE_INFINITY;

        for (int i = 0; i < usersContentScores.size(); i++) {
            if (i == targetUser) {
                continue;
            }

            double similarity = findCosineSimilarity(usersContentScores.get(targetUser), usersContentScores.get(i));

            if (similarity > maxSimilarity) {
                maxSimilarity = similarity;
                mostSimilarUser = i;
            }
        }

        return mostSimilarUser;
    }

    private static String getNormalizedScores(List<Integer> userScores) {
        return userScores.stream()
                .map(score -> String.format("(A%d, %.3f)", userScores.indexOf(score), (score - 1) / 3.0))
                .collect(Collectors.joining(", "));
    }

    private static String getRecommendedContents(int targetUser, List<List<Integer>> usersContentScores, int category) {
        int mostSimilarUser = findMostSimilarUser(targetUser, usersContentScores);
        
